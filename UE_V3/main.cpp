/***
 * 
 *  read_tsv.h
 *  unary_encodingV2
 *  Created by MJ Asuncion on 11/19/22.
 * */
#include "Data_Point.h"
#include "unary_e.h"
#include <vector>
#include <iomanip>
#include <cmath>
#include <iostream>

extern int CELL_COUNT;

extern double x_max, y_max, x_min, y_min;


double cosine_similarity(std::vector<int> A, std::vector<int> B)
{
    double dot = 0.0, denom_a = 0.0, denom_b = 0.0 ;
    REP(i, A.size()) 
    {
        dot += A[i] * B[i] ;
        denom_a += A[i] * A[i] ;
        denom_b += B[i] * B[i] ;
    }
    return dot / (sqrt(denom_a) * sqrt(denom_b)) ;
}

int main()
{
    std::vector<Data_Point> user_location = read_tsv((char *)"test.txt");
    std::vector<Data_Point> est_user_location; //values generated by perturbed estimation
    VECTWODUB map = determine_map();
    std::vector<int> og_sum_of_choices(CELL_COUNT,0);
    std::vector<int> sum_of_choices(CELL_COUNT,0);
    std::vector<int> est_choices(CELL_COUNT,0);
    srand(time(nullptr));

    REP(i,user_location.size())
    {
        user_location.at(i).set_cell(map);
        user_location.at(i).encode_cell();
        user_location.at(i).perturbed_cell = user_location.at(i).original_cell;
        user_location.at(i).perturb_cell();
    }

    populate_sum(user_location,og_sum_of_choices);
    populate_perturbed_sum(user_location,sum_of_choices);

    //populate the estimated choices vect
    REP(i, sum_of_choices.size())
    {
        est_choices.at(i) = (int)estimate(sum_of_choices.at(i));
    }
    
    est_user_location = generate_est_map(est_choices, map);
/*
// Test for random coordination generation BEGIN
    std::vector<double> r_c = random_coord();
    for(auto x: r_c)
    {
        std::cout << std::setprecision(16) << x << ", ";
    }

    std::cout << std::endl;

    std::vector<double> r_c2 = random_coord();
    for(auto x: r_c2)
    {
        std::cout << std::setprecision(16) << x << ", ";
    }
// Test for random coordinate generation END

*/

    std::vector<std::vector<int>> analyzed_query_values;
    std::vector<int> og_generation { }, est_generation { };
    //std::cout << "\n**********Here are the points within a randomly generated radius **********" << std::endl;
    std::cout << "Starting the analysis of the data points in each map...\n";
    REP(i, 10000)
    {

        std::vector<int> analyzed_og_map = generate_dp_in_radius(user_location, est_user_location);
        analyzed_query_values.push_back(analyzed_og_map);

    }
    for(auto i: analyzed_query_values)
    {
        REP(j, i.size())
        {
            if (j == 0)
            {
                og_generation.push_back(i[j]);
            }
            else
            {
                est_generation.push_back(i[j]);
            }
        }
    }
    std::cout << "\n*********Here is the Cosine similarity***********"<< std::endl;
    std::cout << cosine_similarity(og_generation, est_generation);

   // std::cout << "Distance of map going east to west: " << haversine( y_min,x_max, y_min, x_min) << std::endl;

   /* printf("Here is the tally of the unperturbed choices:\n");

    for(auto x:og_sum_of_choices)
    {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    printf("Here is the tally of the perturbed choices:\n");
    for(auto x:sum_of_choices)
    {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    printf("Here is the estimation of the choices:\n");
    for(auto i:est_choices)
    {
        std::cout << i << " ";
    }
    //std::cout << "Cell location\t\t\t\tEstimation\n";
//    for (int i = 0; i < sum_of_choices.size(); i++)
//    {
//        std::cout << i + 1 << "\t\t\t\t\t" << estimate(sum_of_choices[i]) << "\t\t\t\t\t";
//        std::cout << std::endl;
//    }

*/

    return 0;
}
