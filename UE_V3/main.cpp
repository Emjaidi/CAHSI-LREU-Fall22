/***
 * 
 *  read_tsv.h
 *  unary_encodingV2
 *  Created by MJ Asuncion on 11/19/22.
 * */
#include "Data_Point.h"
#include "unary_e.h"
#include <vector>
#include <iomanip>
#include <iostream>

extern int CELL_COUNT;

extern double x_max, y_max, x_min, y_min;

int main()
{
    std::vector<Data_Point> user_location = read_tsv((char *)"test.txt");
    std::vector<Data_Point> est_user_location; //values generated by perturbed estimation
    VECTWODUB map = determine_map();
    std::vector<int> og_sum_of_choices(CELL_COUNT,0);
    std::vector<int> sum_of_choices(CELL_COUNT,0);
    std::vector<int> est_choices(CELL_COUNT,0);

    REP(i,user_location.size())
    {
        user_location.at(i).set_cell(map);
        user_location.at(i).encode_cell();
        user_location.at(i).perturbed_cell = user_location.at(i).original_cell;
        user_location.at(i).perturb_cell();
    }

    populate_sum(user_location,og_sum_of_choices);
    populate_perturbed_sum(user_location,sum_of_choices);

    //populate the estimated choices vect
    REP(i, sum_of_choices.size())
    {
        est_choices.at(i) = (int)estimate(sum_of_choices.at(i));
    }
    
    est_user_location = generate_est_map(est_choices, map);
/*
// Test for random coordination generation BEGIN
    std::vector<double> r_c = random_coord();
    for(auto x: r_c)
    {
        std::cout << std::setprecision(16) << x << ", ";
    }

    std::cout << std::endl;

    std::vector<double> r_c2 = random_coord();
    for(auto x: r_c2)
    {
        std::cout << std::setprecision(16) << x << ", ";
    }
// Test for random coordinate generation END

*/
    std::cout << "\n**********Here are the points within a randomly generated radius **********" << std::endl;
    std::vector<Data_Point> analyzed_og_map = generate_dp_in_radius(user_location);
    for(auto x: analyzed_og_map)
    {
        std::cout << std::setprecision(32) << x.longtitude << ", " << x.latitude << std::endl;
    }
    std::cout << "\n********************"<< std::endl;

   // std::cout << "Distance of map going east to west: " << haversine( y_min,x_max, y_min, x_min) << std::endl;

    printf("Here is the tally of the unperturbed choices:\n");

    for(auto x:og_sum_of_choices)
    {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    printf("Here is the tally of the perturbed choices:\n");
    for(auto x:sum_of_choices)
    {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    printf("Here is the estimation of the choices:\n");
    for(auto i:est_choices)
    {
        std::cout << i << " ";
    }
    //std::cout << "Cell location\t\t\t\tEstimation\n";
//    for (int i = 0; i < sum_of_choices.size(); i++)
//    {
//        std::cout << i + 1 << "\t\t\t\t\t" << estimate(sum_of_choices[i]) << "\t\t\t\t\t";
//        std::cout << std::endl;
//    }


    return 0;
}
